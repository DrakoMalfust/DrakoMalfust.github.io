/**
 * @copyright 2012 - 2016 Crytek GmbH
 * @license http://gface.de/license
 *
 * @NOTE: DEPENDENCY FROM ES6 PROMISE
 */
(function ( global, undefined ) {
    "use strict";

    var debug = false,
        DependenciesHub = function() {
            this.defined = {};
            this.resolvers = {};
            this.pending = [];
            this.map = {
                "backbone": [ "jquery" ],
                "mediator": [ "backbone" ],
                "datatables": [ "jquery" ]
            };
            /**
             * Define dependency but delay resolution
             *
             * @param path
             * @param name
             * @param done
             */
            this.promise = function ( path, name, done ) {
                var that = this;

                if ( this.resolvers.hasOwnProperty( name ) ) {
                    return;
                }

                if ( !this.map.hasOwnProperty( name ) ) {
                    this.map[ name ] = [];
                }

                // load but do not resolve
                if ( this.map.hasOwnProperty( name ) ) {
                    // This promise should be mapped
                    if ( this.canBeMapped( name ) ) {
                        // can be loaded in simple way
                        this.defined[ name ] = this.loadMapped( name, path, function ( resolve ) {
                            // we have promise for current dependency, so we can remove it from pending
                            that.resolvers[ name ] = resolve;
                            done();
                            debug && console.log( "rjs::promise: " + name + " - loaded" );
                            that.processPending();
                        } );
                    } else {
                        debug && console.log( "rjs::promise: " + name + " - pending" );
                        // we have to wait for all dependencies
                        this.pending.push( {
                            type: "define",
                            path: path,
                            name: name,
                            done: done
                        } );
                    }
                } else {
                    this.defined[ name ] = new Promise( function ( resolve ) {
                        that.load( path, function() {
                            resolve();
                            done();
                            debug && console.log( "rjs::define: " + name + " - loaded" );
                            that.processPending();
                        } );
                    } );
                }
            };
            /**
             * Resolve loaded dependency with promise()
             * @param name
             */
            this.resolve = function ( name ) {
                if ( typeof( this.resolvers[ name ] ) !== "undefined" ) {
                    // resolve
                    this.resolvers[ name ]();
                    debug && console.log( "rjs::resolve: " + name + " - resolved" );
                    this.processPending();
                }
            };

            /**
             *
             * @param path
             * @param name
             * @param done
             */
            this.define = function ( path, name, done ) {
                var that = this;
                if ( this.defined.hasOwnProperty( name ) ) {
                    return;
                }

                if ( this.map.hasOwnProperty( name ) ) {
                    // This promise should be mapped
                    if ( this.canBeMapped( name ) ) {
                        // can be loaded in simple way
                        this.defined[ name ] = this.loadMapped( name, path, function ( resolve ) {
                            // we have promise for current dependency, so we can remove it from pending
                            resolve();
                            done();
                            debug && console.log( "rjs::define: " + name + " - loaded" );
                            that.processPending();
                        } );
                    } else {
                        debug && console.log( "rjs::define: " + name + " - pending" );
                        // we have to wait for all dependencies
                        this.pending.push( {
                            type: "define",
                            path: path,
                            name: name,
                            done: done
                        } );
                    }
                } else {
                    this.defined[ name ] = new Promise( function ( resolve ) {
                        that.load( path, function() {
                            resolve();
                            done();
                            debug && console.log( "rjs::define: " + name + " - loaded" );
                            that.processPending();
                        } );
                    } );
                }
            };

            /**
             *
             * @param dependencies
             * @param done
             */
            this.require = function ( dependencies, done ) {
                // create promise for require request
                var list = [],
                    canBeRequested = dependencies.every( function ( dependencyName ) {
                        if ( typeof(this.defined[ dependencyName ]) !== "undefined" ) {
                            list.push( this.defined[ dependencyName ] );
                            return true;
                        }

                        return false;
                    }.bind( this ) );

                // check that all dependencies were defined
                if ( canBeRequested ) {
                    Promise.all( list ).then( function() {
                        done();
                        debug && console.log( "rjs::require: ", dependencies, " - resolved" );
                        this.processPending();
                    }.bind( this ) );
                } else {
                    debug && console.log( "rjs::require: ", dependencies, " - pending" );
                    // we have to wait for all dependencies
                    this.pending.push( {
                        type: "require",
                        dependencies: dependencies,
                        done: done
                    } );
                }
            };

            /**
             * Check that all dependencies were loaded for current dependency
             * @param name
             * @returns {boolean}
             */
            this.canBeMapped = function ( name ) {
                var that = this,
                    result = true;

                this.map[ name ].forEach( function ( dependencyName ) {
                    // that should be a name
                    result = result && typeof( that.defined[ dependencyName ] ) !== "undefined";
                } );

                return result;
            };

            /**
             * Create promise for current dependency
             *
             * @param name
             * @param path
             * @param done
             * @returns {Promise}
             */
            this.loadMapped = function ( name, path, done ) {
                var that = this,
                    list = [];

                this.map[ name ].forEach( function ( dependency ) {
                    list.push( that.defined[ dependency ] );
                } );

                // Promise.all will be resolved faster than it trigger then method,
                // so wrap Promise in Promise and go deeper
                return new Promise( function ( resolve ) {
                    Promise.all( list ).then( function() {
                        that.load( path, function() {
                            done( resolve );
                        } );
                    } )
                } );
            };

            /**
             * Load file of dependency
             * @param path
             * @param onLoad
             * @param onError
             */
            this.load = function ( path, onLoad, onError ) {
                var script = global.document.createElement( "script" );

                script.type = "text/javascript";
                script.src = path;
                script.async = true;
                script.onerror = onError;
                script.onload = onLoad;

                global.document.body.appendChild( script );
            };

            /**
             * Process pending items in queue
             */
            this.processPending = function() {
                var that = this,
                    list = this.pending;
                this.pending = [];

                // try to resolve definitions at first
                list.forEach( function ( item ) {
                    if ( "define" === item.type ) {
                        that.define( item.path, item.name, item.done );
                    }
                } );

                // try to resolve requires
                list.forEach( function ( item ) {
                    if ( "require" === item.type ) {
                        that.require( item.dependencies, item.done );
                    }
                } );
            };
        },
        Rjs = function() {
            try {
                debug = global.localStorage.logging === "on";
            } catch ( e ) {
                debug = false;
            }

            this.hub = new DependenciesHub();

            /**
             * Define dependency
             * @param path
             * @param name
             * @param done
             */
            this.define = function ( path, name, done ) {
                if ( typeof (name) !== "string" || name.length === 0 ) {
                    throw new Error( "Name should be defined as string" );
                }

                debug && console.log( "rjs::define: " + name );
                done = typeof( done ) === "function" ? done : function() {
                };

                // registration of new
                this.hub.define( path, name, done );
            };

            /**
             * Request for load dependencies
             * @param dependencies - list of dependencies names
             * @param done - on resolve callback
             */
            this.require = function ( dependencies, done ) {
                debug && console.log( "rjs::require: ", dependencies );

                done = typeof( done ) === "function" ? done : function() {
                };

                this.hub.require( dependencies, done );
            };
            /**
             * Define dependency with promise
             *
             * @param path
             * @param name
             * @param done
             */
            this.promise = function ( path, name, done ) {
                if ( typeof (name) !== "string" || name.length === 0 ) {
                    throw new Error( "Name should be defined as string" );
                }

                debug && console.log( "rjs::promise: " + name );
                done = typeof( done ) === "function" ? done : function() {
                };

                // registration of new
                this.hub.promise( path, name, done );
            };
            /**
             * Resolve loaded dependency with promise()
             * @param name
             */
            this.resolve = function( name ) {
                this.hub.resolve( name );
            }
        };

    global.rjs = new Rjs();

}( this ));